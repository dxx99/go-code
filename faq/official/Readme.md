[TOC]
## [官方相关问题汇总](https://golang.org/doc/faq)

### 由来
#### 项目的目的？创建的原因？祖先是谁？
- 利用多核cpu, 为并发或并行提供支持，自动垃圾收集，严格依赖规范
- 高效编译，高效执行，易于编程
- c语言 + Newsqueak(limbo)并发

#### 设计原则？
- 实现效率，安全和流动性
- 没有前向声明和头文件
- 一切都只声明一次
- 初始化具有表现力，自动且易于使用
- 关键字的语法简洁明了
- 保持概念正交
  - 可以为任何类型实现方法
  - 结构代表数据，而接口代表抽象
    
### 设计
#### runtime
- 每个程序的一部分
- 实现go语言的垃圾收集，并发，堆栈管理和其他关键特性，类似于libc库

#### 为啥没有泛型
- [泛型建议](https://golang.org/issue/43651) 已被接纳
- 预计在1.18版本可以使用
- 泛型很方便，但是代价是类型系统和运行时的复杂性
- [泛型方案提案](https://github.com/golang/go/issues/15292)

#### 为啥没有异常处理
- 将异常耦合到控制结构(try-catch-finally)，会导致代码错综复杂，会将过多的普通错误(eg. 无法打开文件)标记为异常
- go通过多值返回在不重载返回值的情况下报告错误变得容易
- go还有内置函数，用于发送信号并从真正的异常情况中恢复
- 恢复机制： 在发生错误后被删除的函数状态的一部分执行，不需要额外的控制结构
- [错误处理](https://blog.golang.org/defer-panic-and-recover)
- [干净处理错误](https://blog.golang.org/errors-are-values)

#### 为啥没有断言
- 不希望程序员将断言用作依赖，以避免考虑正确的错误处理和报告
- 没有assert关键字，使用 val.(T) 来对变量进行断言
- reflect.TypeOf(val)  查看变量的类型

#### 为啥要使用csp上构建并发
- 由于其他语法的[复杂设计](https://en.wikipedia.org/wiki/POSIX_Threads)
- 过多的细节：互斥锁，条件变量，[内存屏障???](???)
- 为并发提供高级语言支持的最成功模型(csp)

#### 为啥使用goroutine而不是线程
- goroutine的设计会使并发易于使用
- 独立执行的函数-协程-复用到一组线程上，更加容易的处理阻塞
- 更加轻量，除了堆栈内存之外，几乎没有开销
- 为了使堆栈变小，go的runtime使用可调整大小的[有界堆栈???](???)
- runtime会自动增加(收缩)用于存储堆栈的内存
- 总结：轻量-并发容易

#### 为什么没有将map定义为原子的？
- 要求所有的map操作加互斥锁会减慢大多数程序的速度
- 不受控制的map会导致程序崩溃
- [原子操作](https://blog.csdn.net/codragon/article/details/112526621)

### 类型
#### go是面向对象语言吗？
- 是或否，有类型或方法，并允许面向对象编程风格，但没有类型层次结构
- 接口 类型嵌套
- 面向对象三大语言特点
  - 封装：通过首字母大小写来实现是否能被导出
  - 继承：通过组合实现
  - 多态：通过接口实现
  
#### 如何获取方法的动态调度
- 动态调度方法的唯一方法是通过接口。
- 结构体或任何其他具体类型上的方法总是静态解析的。

#### 为啥不支持重载
- 相同的函数名，不同的函数签名有时很有用，但实践会令人困惑和脆弱，仅按名称匹配并要求类型的一致性是 Go 类型系统中一个主要的简化决定。
- 由于重载不是必须的，没有，系统反而更加简单

#### 为啥没有implements声明
- go通过实现接口的所有方法签名来表示实现了该接口
- go接口的语义使go具有敏姐，轻量级的主要原因之一

#### 如果保证某个对象实现了某个接口
```go
package main
type T struct{}
type I interface {}
var _ I = T{}           // Verify that T implements I.
var _ I = (*T)(nil)     // Verify that *T implements I.
```

#### []T类型是否可以覆盖给[]interface{} 
- 可以
- [示例](../../tips/interface/interface-implements/interface_to_t.go)

#### 如何T1和T2有相同的底层结构，可以直接将[]T1转换成T2?
- 不可以
- 复合数据的类型转换没法直接使用转换
- [示例](../../tips/interface/interface-implements/convert_T_same_underlying_type.go)


#### 为什么我的nil错误值不等于nil


